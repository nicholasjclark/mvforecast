% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/thief_reconcile.R
\name{thief_reconcile}
\alias{thief_reconcile}
\title{Temporal hierarchy reconciliation of previously fitted univariate forecast}
\usage{
thief_reconcile(
  y,
  original_forecast,
  lambda = NULL,
  frequency,
  return_aggregates = FALSE
)
}
\arguments{
\item{y}{\code{xts matrix}. The outcome series to be modelled. \code{NAs} are currently not supported}

\item{original_forecast}{Either a \code{forecast} or \code{list} object, the latter of which must contain slots
named \code{forecast} (containing the mean, upper interval and lower interval forecasts) and \code{residuals} (containing
residuals for the fitted forecast model)}

\item{lambda}{\code{numeric}. The Box Cox power transformation parameter for all series. Must be
between \code{-1} and \code{2} inclusive. If \code{y} contains zeros, \code{lambda} will be set to
\code{max(c(0.7, lambda))} to ensure stability of forecasts}

\item{frequency}{\code{integer}. The seasonal frequency in \code{y}}

\item{return_aggregates}{\code{Logical}. If \code{TRUE}, the forecasts and residuals for the aggregate series will
also be returned}
}
\description{
This function fits ensemble univariate forecast models on all levels of temporal
aggregation for a series and reconciles the supplied univariate forecast object
}
\details{
Series in \code{y} are aggregated at all possible levels up to annual using \code{\link[thief]{tsaggregates}}.
\code{\link{ensemble_base}} is used on all levels of aggregation to find a weighted ensemble of nine
univariate forecast models that minimises mean absolute scaled error. Forecasts are then reconciled
using \code{\link[thief]{reconcilethief}} and are optionally constrained using non-negative optimisation if there are no
negative values in \code{y}. Adjustments to the original supplied forecast are incorporated and
this adjusted forecast is returned
}
\examples{
\donttest{
library(mvforecast)
data("ixodes_vets_dat")

#Fit a univariate model to one of the series in the ixodes data
y <- ixodes_vets_dat$y_train[,1]
xts.to.ts <- function(x, freq = 52) {
start_time <- floor((lubridate::yday(start(x)) / 365) * freq)
ts(as.numeric(x), start = c(lubridate::year(start(x)), start_time), freq = freq)}

original_forecast <- forecast(auto.arima(xts.to.ts(y, freq = 52)), h = 52)
reconciled <- thief_reconcile(y = y, original_forecast = original_forecast, frequency = 52)}

#Plot the original and reconciled forecasts
reconciled <- thief_reconcile(y = y, original_forecast = original_forecast, frequency = 52)
autoplot(original_forecast)
autoplot(reconciled)

}
\references{
Athanasopoulos, G., Hyndman, R.,  Kourentzes, N.,  and Petropoulos, F. Forecasting with temporal hierarchies.
(2017) European Journal of Operational Research 262(1) 60â€“74
}
\seealso{
\code{\link[thief]{reconcilethief}}
}
