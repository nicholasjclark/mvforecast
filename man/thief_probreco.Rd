% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/thief_probreco.R
\name{thief_probreco}
\alias{thief_probreco}
\title{Probabilistic reconciliation of temporally reconciled grouped forecasts}
\usage{
thief_probreco(
  y,
  k = 1,
  frequency = 52,
  lambda = NULL,
  model = "thief_ensemble",
  prob_train_horizon = 2,
  horizon = NULL,
  max_agg = NULL,
  groups,
  keep_total = TRUE,
  cores = parallel::detectCores() - 1,
  discrete = FALSE,
  ...
)
}
\arguments{
\item{y}{\code{xts matrix}. The outcome series to be modelled. \code{NAs} are currently not supported}

\item{k}{\code{integer} specifying the length of the forecast horizon in multiples of \code{frequency}. Default
is \code{1}, meaning that a final forecast of \code{frequency} horizons will be returned}

\item{frequency}{\code{integer}. The seasonal frequency in \code{y}}

\item{lambda}{\code{numeric}. The Box Cox power transformation parameter for aggregate series. Must be
between \code{-1} and \code{2} inclusive. If \code{y_series} contains zeros, \code{lambda} will be set to
\code{max(c(0.7, lambda))} to ensure stability of forecasts}

\item{model}{One of code{c(thief_ensemble, thief_rfsrc, thief_vets)}}

\item{prob_train_horizon}{\code{integer} specifying the number of observations to holdout of \code{y} for training the
probabilistic reconciliation weights. Models are first fitted to a subset of \code{y} that has removed the last
\code{prob_train_horizon} observations, and these are used as cross-validation observations to train the reconciliation weights.
Once trained, models are refitted to the full series in \code{y} and forecasts are used alongside reconciliation weights to
formulate the reconciled forecast. Should be \code{>1} to provide at least some variation to \code{\link[ProbReco]{scoreopt}}.
Default is \code{2}}

\item{horizon}{\code{integer}. The horizon to forecast. Defaults to \code{frequency}}

\item{max_agg}{(optional) \code{integer} specifying the maximum number of temporal aggregation levels
to use when reconciling, via the structural scaling method. Useful if higher levels of aggregation
are unlikely to have 'seen' recent changes in series dynamics and will likely then result in poor
forecasts as a result. Default is \code{NULL}, meaning that all levels of aggregation are used
#'@param discrete \code{logical} Is the series in \code{y} discrete? If \code{TRUE}, use a copula-based method
relying on the Probability Integral Transform to map the series to an approximate Gaussian distribution prior to modelling.
Forecasts are then back-transformed to the estimated discrete distribution that best fits \code{y}. Default is \code{FALSE}}

\item{groups}{Group matrix indicates the group structure, with one column for each series when
completely disaggregated, and one row or each grouping of the time series. It allows either a numerical matrix or a
matrix consisting of strings that can be used for labelling. See \code{\link[hts]{gts}} for more details}

\item{keep_total}{\code{logical}. If \code{TRUE}, forecasts for the the top-level summed series (the total)
will also be returned as the last element in the returned list of forecast distributions}

\item{cores}{\code{integer}. The number of cores to use}

\item{...}{Other arguments to be passed on to the specified thief model}
}
\value{
A \code{list} containing the reconciled forecast distributions for each series in \code{y}. Each element in
the \code{list} is a \code{horizon x 1000 matrix} of forecast predictions
}
\description{
This function fits a specified thief model and then uses probabilistic reconciliation based on the supplied
grouping structure to reconcile base forecast distributions
}
\details{
Series in \code{y} are aggregated at all possible levels up to annual using \code{\link[thief]{tsaggregates}}.
The specified model is used on the unaggregated series, with forecasts reconciled
using \code{\link[thief]{reconcilethief}}. Finally, the grouping structure is used in \code{\link[hts]{gts}} to create
the group summing structure. Forecasts of the summed series, including the final total, are generated using
\code{\link{thief_ensemble}} and the final base forecast distributions are reconciled using weights calculated through
energy score optimisation using \code{\link[ProbReco]{scoreopt}}
}
\examples{
\donttest{
library(mvforecast)
data("ixodes_vets_dat")

#Fit a probabilistic thief_ensemble model
groups <- ixodes_vets_dat$groups
mod1 <- thief_probreco(y = ixodes_vets_dat$y_train,
model = 'thief_ensemble',
frequency = 52,
prob_train_horizon = 12,
keep_total = FALSE,
groups = groups)

#Calculate the out-of-sample CRPS
calc_crps(mod1, y_test = ixodes_vets_dat$y_test)

Plot simulation results for one of the plots in the NEON dataset
plot_mvforecast(simulation = mod1[[4]])
points(as.vector(ixodes_vets_dat$y_test[,4]))}

}
\references{
Athanasopoulos, G., Hyndman, R.,  Kourentzes, N., and Petropoulos, F. Forecasting with temporal hierarchies.
(2017) European Journal of Operational Research 262(1) 60â€“74 \cr\cr
Panagiotelis, A., Gamakumara, P., Athanasopoulos, G., and Hyndman, R.
Probabilistic Forecast Reconciliation: Propoerties, Evaluation and Score Optimisation. (2020)
Monash EBS Working Paper 26/20 \cr\cr
Panagiotelis, A., Athanasopoulos, G., Gamakumara, P., and Hyndman, R. (2021). Forecast reconciliation:
A geometric view with new insights on bias correction. International Journal of Forecasting, 37(1), 343-359.
}
\seealso{
\code{\link{thief_ensemble}}, \code{\link[hts]{gts}},
\code{\link[thief]{reconcilethief}}, \code{\link[ProbReco]{scoreopt}}
}
